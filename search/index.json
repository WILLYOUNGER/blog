[{"content":"pinus 学习（二）默认组件介绍 上节介绍了pinus框架创建的helloworld示例工程的创建,编译,运行,以及服务器启动的源码分析 下面来看一下各个组件的具体实现与功能\nProxyComponent rpc的客户端，在服务器启动后由Monitor组件监视到rpc服务器后添加rpc服务器，使用惰性连接，在第一次使用的时候才会和rpc服务器建立连接，可以自定义使用的协议，默认使用的是mqtt协议\nRemoteComponent rpc服务器，默认使用mqtt协议，会在构造函数里读取服务器组件中的remote和插件中的remote，然后再start里设置\nMonitorComponent BackendSessionComponent ServerComponent MasterComponent ","date":"2024-05-29T00:00:00Z","permalink":"https://xinxiao.wang/p/pinuslearn2/","title":"pinus 学习（二）默认组件介绍"},{"content":"pinus 学习（一）项目结构与源码分析启动 项目结构介绍，项目入口，服务器启动流程介绍\n目录结构 创建一个helloworld示例工程，会创建两个服务器，一个game-server一个web-server，game-server是游戏服务器，目录结构如下\n目录app中存放项目代码 目录config中存放服务器配置 目录dist是编译后生成的目录 目录node_modules是第三方库包 文件app.ts是服务器入口 文件copy.js 功能是将配置文件拷贝到dist目录 文件preload.ts实现捕获错误 文件package.js与package-lock.json 是npm包管理配置文件 （依赖的第三方库和自定义脚本） 文件tsconfig.json 是 typescript项目的配置文件（编译的配置与需要编译的文件） 项目结构 创建的helloworld的示例工程的game-server中启动了两个服务器，master服务器和connector服务器\n服务器中通过添加组件(component)来增加功能\nmaster服务器 MasterComponent 监控功能，启动了其他服务器\nMonitorComponent 监控功能\nconnector服务器 ProxyComponent rpc 中 的client，调用其他服务器的函数\nRemoteComponent rpc 中 的server，服务与其他服务器，接收其他服务器的调用\nConnectionComponent 前台服务器才有，管理连接上的用户信息与用户数量\nConnectorComponent 前台服务器才有，管理用户连接，发送与接受消息，（根据配置会决定是否启动DictionaryComponent和ProtobufComponent）\nSessionComponent 前台服务器才有，管理sessionID与socket的对应关系，sessionID在connectorComponent中设置\nPushSchedulerComponent 前台服务器才有，推送消息\nBackendSessionComponent 绑定后台服务器sessionID与（用户和前台服务器）的关系，连接绑定前台服务器与后台服务器的用户\nChannelComponent 将几个用户串成一组，可以群发消息\nServerComponent 服务器功能，其中有Filter（过滤器），Handler（处理某条客户端消息），Crons（一些定时任务）\nMonitorComponent 监控功能\n项目启动 在game-server目录中执行npm i安装第三方依赖，然后运行tsc，编译TS代码，编译结果将输出到dist文件夹中，然后运行node cooy 拷贝配置文件到dist目录中，再在dist目录中执行node app ,服务器就启动了。\n源码分析 app.ts 这个文件是入口，创建项目后默认的代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import { pinus } from \u0026#39;pinus\u0026#39;; import { preload } from \u0026#39;./preload\u0026#39;; /** * 替换全局Promise * 自动解析sourcemap * 捕获全局错误 */ preload(); /** * Init app for client. */ let app = pinus.createApp(); app.set(\u0026#39;name\u0026#39;, \u0026#39;helloworld\u0026#39;); // app configuration app.configure(\u0026#39;production|development\u0026#39;, \u0026#39;connector\u0026#39;, function () { app.set(\u0026#39;connectorConfig\u0026#39;, { connector: pinus.connectors.hybridconnector, heartbeat: 3, useDict: true, useProtobuf: true }); }); // start app app.start(); 这里会启动Master服务器，app.configure的第二个参数说明，这个配置是connector服务器的配置，master在这里不会执行， app.start（）中会加载Master服务器的两个默认Component，并初始化，然后再根据配置文件servers.json去启动connector服务器\n先来看下app.ts里面的内容\nlet app = pinus.createApp(); 这里创建了Application类，在createApp中调用了init，然后使用app.configure() 来给每个服务器设置配置，添加自定义组件，最后app.start() 启动服务器\npinus.createApp() 创建一个application，其中init函数如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 init(opts ?: ApplicationOptions) { opts = opts || {}; let base = opts.base || path.dirname(require.main.filename); this.set(Constants.RESERVED.BASE, base); this.base = base;\t//设置项目根目录 appUtil.defaultConfiguration(this); this.state = STATE_INITED; logger.info(\u0026#39;application inited: %j\u0026#39;, this.getServerId()); } appUtil.ts export function defaultConfiguration(app: Application) { let args = parseArgs(process.argv);//解析运行命令参数 setupEnv(app, args);\t//设置当前环境（Development或是Production） loadMaster(app);\t//从config目录中读取master.json配置记录 loadServers(app);\t//从config目录中读取servers.json配置记录 processArgs(app, args);\t//解析命令行参数，这里面只有master服务器可以从命令行中获取参数，其他服务器都会从配置文件中获取参数 configLogger(app);\t//配置日志 loadLifecycle(app);\t//helloworld示例工程中没有，根据后面的代码，猜测是插件的加载（插件在后面介绍，大概是一系列功能的集合） } app.configure() 根据传入的env和type来决定是否要执行fn里的内容，helloworld示例工程中的这个函数，只有connector服务器需要执行\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 configure(fn: ConfigureCallback): Application; configure(env: string, fn: ConfigureCallback): Application; configure(env: string, type: string, fn: ConfigureCallback): Application; configure(env: string | ConfigureCallback, type ?: string | ConfigureCallback, fn ?: ConfigureCallback): Application { let args = [].slice.call(arguments); fn = args.pop(); env = type = Constants.RESERVED.ALL; if (args.length \u0026gt; 0) { env = args[0]; } if (args.length \u0026gt; 1) { type = args[1]; } if (env === Constants.RESERVED.ALL || contains(this.settings.env, env as string)) { if (type === Constants.RESERVED.ALL || contains(this.settings.serverType, type as string)) { fn.call(this); } } return this; } app.start() 读取完配置后，这里正式启动服务器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 start(cb ?: (err ?: Error, result ?: void) =\u0026gt; void) { this.startTime = Date.now(); if (this.state \u0026gt; STATE_INITED) { utils.invokeCallback(cb, new Error(\u0026#39;application has already start.\u0026#39;)); return; } let self = this; appUtil.startByType(self, function () { appUtil.loadDefaultComponents(self); let startUp = function () { self.state = STATE_BEFORE_START; logger.info(\u0026#39;%j enter before start...\u0026#39;, self.getServerId()); appUtil.optComponents(self.loaded, Constants.RESERVED.BEFORE_START, function (err) { if (err) { utils.invokeCallback(cb, err); } else { logger.info(\u0026#39;%j enter start...\u0026#39;, self.getServerId()); appUtil.optComponents(self.loaded, Constants.RESERVED.START, function (err) { self.state = STATE_START; if (err) { utils.invokeCallback(cb, err); } else { logger.info(\u0026#39;%j enter after start...\u0026#39;, self.getServerId()); self.afterStart(cb); } }); } }); }; appUtil.optLifecycles(self.usedPlugins, Constants.LIFECYCLE.BEFORE_STARTUP, self, function (err) { if (err) { utils.invokeCallback(cb, err); } else { startUp(); } }); }); } appUtil.startByType，这个函数可以根据配置决定是否通过master服务器来启动其他服务器，如果不通过master服务器启动，会直接在这里启动服务，start（）后面的逻辑也不会执行了，\n如果通过Master服务器启动，会执行回调函数，回调函数中appUtil.loadDefaultComponents(self); 加载了默认的组件，项目结构中介绍了的组件全部是默认组件，connector服务器的组件就是非master服务器的默认组件。\n加载默认组件会直接创建出来，调用构造函数。\n下面通过appUtil.optLifecycles 执行每个插件的beforeStartup，然后再通过appUtil.optComponents 执行每个组件的beforeStart与start，然后执行 self.afterStart(cb);，afterStart里面将执行每个组件的afterStart和每个插件的afterStartup\n最后发送start_server信号，一个服务器就启动了\n组件和插件中的afterStartAll，将会再所有服务器启动后执行，这是单个服务器启动的逻辑，所以没有调用\n","date":"2024-05-28T00:00:00Z","permalink":"https://xinxiao.wang/p/pinuslearn1/","title":"pinus 学习（一）项目结构与源码分析启动"},{"content":"常见线程锁介绍（C++） 互斥锁、条件锁（条件变量）、自旋锁、读写锁、递归锁的应用\n互斥锁 在多线程情况下，不同线程争对同一份临界资源进行操作时使用的锁，保证临界资源只有一个线程使用，C++ 11 中引入了std:mutex ，linux平台C函数中也有方法\n加锁后需要解锁，其他线程才能进入，否则会一直等待\nC函数（Linux） 1 2 3 4 5 6 7 8 9 10 11 12 // 声明一个互斥量 pthread_mutex_t mtx; // 初始化 pthread_mutex_init(\u0026amp;mtx, NULL); // 加锁 pthread_mutex_lock(\u0026amp;mtx); // 解锁 pthread_mutex_unlock(\u0026amp;mtx); // 销毁 pthread_mutex_destroy(\u0026amp;mtx); // 尝试加锁，加锁成功返回0 pthread_mutex_trylock(\u0026amp;mtx); C11 (全平台) 1 2 3 4 5 6 7 8 9 10 11 12 13 // 声明一个互斥量（std::mutex不允许拷贝构造，也不允许 move 拷贝） std::mutex mtx; // 加锁 mtx.lock(); // 解锁 mtx.unlock(); // 尝试加锁，加锁成功返回true mtx.try_lock(); //RAII应用，使用unique_lock和lock_guard通过构造和析构自动加锁解锁 std::unique_lock\u0026lt;std::mutex\u0026gt; locker(mtx); std::lock_guard\u0026lt;std::mutex\u0026gt; locker(mtx); //unique_lock可以手动加锁解锁，lock_guard只能通过构造析构加锁解锁 条件锁（条件变量） 多线程中，未满足条件的线程会阻塞住，直到条件满足将继续执行的情况下使用的锁\nC函数（Linux) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // 申明一个互斥量 pthread_cond_t cond; // 初始化 pthread_cond_init(\u0026amp;cond); // 销毁 pthread_cond_destroy(\u0026amp;cond); /** 阻塞等待一个条件变量 * 这里将执行三个操作： * 1. 阻塞并等待条件变量cond满足 * 2. 释放已锁住的互斥锁mtx，（相当于pthread_mutex_unlock(\u0026amp;mtx);） *\t3. 被唤醒后，pthread_cond_wait返回时，解除阻塞并锁住mtx（相当于pthread_mutex_nlock(\u0026amp;mtx);） * 为什么需要搭配互斥锁mtx使用将在后面解释 */ pthread_cond_wait(\u0026amp;cond, \u0026amp;mtx); struct timespec { time_t tv_sec; // seconds 秒 long tv_nsec; // nanosecondes 纳秒 } timespec abstime; /** 限时阻塞等待一个条件变量 * 除了执行pthread_cond_wait(\u0026amp;cond, \u0026amp;mtx);的操作 * 还会在abstime时间内等待 * 需要注意的是，abstime要填的是1970年1月1日以来到想要停止的时间的秒数 * 超时将返回ETIMEDOUT（非0） */ pthread_cond_timedwait(\u0026amp;cond, \u0026amp;mtx， \u0026amp;abstime); // 唤醒至少一个阻塞在条件变量上的线程 pthread_cond_signal(\u0026amp;cond); // 唤醒全部阻塞在条件变量上的线程 pthread_cond_broadcast(\u0026amp;cond); C11（全平台） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 申明一个条件变量 std::condition_variable cv; std::lock_guard\u0026lt;std::mutex\u0026gt; locker(mtx); //这里将要使用互斥锁中的unique_lock /** 阻塞等待一个条件变量 * 这里将执行三个操作： * 1. 阻塞并等待条件变量cv满足 * 2. 释放已锁住的互斥锁mtx，（相当于locker.unlock()） *\t3. 被唤醒后，wait返回时，解除阻塞并锁住mtx（相当于locker.lock()） * 为什么需要搭配互斥锁mtx使用将在后面解释 */ cv.wait(locker); // 限时阻塞等待一个条件变量，知道经过多久时间，超时将返回false cv.wait_for(locker, rel_time); // 限时阻塞等待一个条件变量，直到等到某个时间点，超时将返回false cv.wait_unitl(locker, point_time); // 唤醒一个在cv上等待的线程 cv.notify_one(); // 唤醒任何在cv上等待的线程 cv.notify_all() 为什么条件锁（条件变量）需要搭配互斥锁使用（作为参数传入）？\n会出现虚假唤醒的情况，所以需要传入一个locker，防止notify_one（signal）后多个wait同时响应\n自旋锁 在多线程情况下，不同线程争对同一份临界资源进行操作时使用的锁，保证临界资源只有一个线程使用，与互斥锁不同的地方在于，如果临界资源被占用，互斥锁会阻塞等待，自旋锁会循环获取锁\n当等待时间较短时可以选择使用自旋锁，可以减少操作系统的用户态与内核态的转换，等待时间较长选择使用互斥锁。\n自旋锁在C11中并没有给出实现，需要自己使用std::atomic来进行实现\nC函数（Linux） 1 2 3 4 5 6 7 8 9 10 11 12 // 声明一个互斥量 pthread_spinlock_t lock; // 初始化 pthread_spin_init(\u0026amp;lock); // 加锁 pthread_spin_lock(\u0026amp;lock); // 解锁 pthread_spin_unlock(\u0026amp;lock); //销毁 pthread_spin_destroy(\u0026amp;lock); // 尝试加锁，加锁成功返回0 pthread_spin_trylock(\u0026amp;lock); C11(全平台) 这里使用atomic实现了自旋锁\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 使用C++11的原子操作实现自旋锁（默认内存序，memory_order_seq_cst） class spin_mutex { // flag对象所封装的bool值为false时，说明自旋锁未被线程占有。 std::atomic\u0026lt;bool\u0026gt; flag = ATOMIC_VAR_INIT(false); public: spin_mutex() = default; spin_mutex(const spin_mutex\u0026amp;) = delete; spin_mutex\u0026amp; operator= (const spin_mutex\u0026amp;) = delete; void lock() { bool expected = false; // CAS原子操作。判断flag对象封装的bool值是否为期望值(false)，若为bool值为false，与期望值相等，说明自旋锁空闲。 // 此时，flag对象封装的bool值写入true，CAS操作成功，结束循环，即上锁成功。 // 若bool值为为true，与期望值不相等，说明自旋锁被其它线程占据，即CAS操作不成功。然后，由于while循环一直重试，直到CAS操作成功为止。 while(!flag.compare_exchange_strong(expected, true)){ expected = false; } } void unlock() { flag.store(false); } }; 读写锁 多线程中对，临界资源的访问方式有两种：读和写。其中，写操作是独占的而读操作是非独占的，多个线程可以同时读这个共享变量，读写锁就可以用在这种情况下\nC函数（Linux) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 声明一个读写锁 pthread_rwlock_t m_rw_lock; // 初始化 pthread_rwlock_init(\u0026amp;m_rw_lock, NULL); // 读加锁 pthread_rwlock_rdlock(pthread_rwlock_t*); // 读尝试加锁，成功返回0 pthread_rwlock_tryrdlock(pthread_rwlock_t*); // 写加锁 pthread_rwlock_wrlock(pthread_rwlock_t*); // 写尝试加锁，成功返回0 pthread_rwlock_trywrlock(pthread_rwlock_t*); // 解锁 pthread_rwlock_unlock(pthread_rwlock_t*); // 销毁 pthread_rwlock_destroy(pthread_rwlock_t* ); C17（全平台） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 声明 std::shared_mutex mtx; //独占锁定 // 加锁 mtx.lock(); // 解锁 mtx.unlock(); // 尝试加锁，加锁成功返回true mtx.try_lock(); //共享锁定 // 加锁 mtx.lock_shared(); // 解锁 mtx.unlock_shared(); // 尝试加锁，加锁成功返回true mtx.try_lock_shared(); //RAII应用，使用unique_lock和shared_lock通过构造和析构自动加锁解锁 //shared_lock是在读的时候使用，unique_lock在写的时候使用 std::unique_lock\u0026lt;std::mutex\u0026gt; locker(mtx); std::shared_lock\u0026lt;std::mutex\u0026gt; locker(mtx); 递归锁 递归锁可以重复加锁，会记录加锁的次数，每次加锁，计数+1，且判断如果已经锁住，不做处理，每次解锁，计数-1\nC 函数（Linux) 1 2 3 4 5 6 7 8 9 10 11 12 // 声明 pthread_mutexattr_t attr; // 初始化 pthread_mutexattr_init(\u0026amp;mtx, NULL); // 加锁 pthread_mutexattr_lock(\u0026amp;mtx); // 解锁 pthread_mutexattr_unlock(\u0026amp;mtx); // 销毁 pthread_mutexattr_destroy(\u0026amp;mtx); // 尝试加锁，加锁成功返回0 pthread_mutexattr_trylock(\u0026amp;mtx); C11（全平台） 1 2 3 4 5 6 7 8 9 10 11 12 13 // 声明 std::recursive_mutex rmtx; // 加锁 rmtx.lock(); // 解锁 rmtx.unlock(); // 尝试加锁，加锁成功返回true rmtx.try_lock(); //RAII应用，使用unique_lock和lock_guard通过构造和析构自动加锁解锁 std::unique_lock\u0026lt;std::mutex\u0026gt; locker(rmtx); std::lock_guard\u0026lt;std::mutex\u0026gt; locker(rmtx); //unique_lock可以手动加锁解锁，lock_guard只能通过构造析构加锁解锁 ","date":"2024-05-25T00:00:00Z","permalink":"https://xinxiao.wang/p/threadlockcpp/","title":"常见线程锁介绍（C++）"},{"content":"C/C++编码规范 以下编码规则仅适用于王新晓的 C/C++代码\n一、文件结构 头文件规范 一个头文件需要 #define保护，命名格式为：_\u0026lt;PROJECT\u0026gt;_\u0026lt;PATH\u0026gt;_\u0026lt;FILE\u0026gt;_H_ 如：项目xzpt中，头文件xzpt\\Classes\\xzpt\\xzptGameSence.h应定义如下：（需要写全路径）（宏定义 #endif 后须加注释） 1 2 3 #ifndef _XZPT_XZPT_XZPTGAMESENCE_H_ #define _XZPT_XZPT_XZPTGAMESENCE_H_ #endif // _XZPT_XZPT_XZPTGAMESENCE_H_ #include的顺序（每种头文件间应空行） 当前文件的对应头文件 C系统文件 C++系统文件 其他库的头文件 本项目的头文件 二、命名规范 文件命名 使用小驼峰法命名如： xzptGameSence.cpp xzptGameSence.h\n类型命名 class 开头为 C， struct开头为S， interface开头为I 大驼峰法 例如： CXzptGameSence SXzptUserInfo IXzptLogin\n变量命名 指针需在结尾添加_ptr，若为常量指针（我这里的意思是指针不能改变指向的东西，但是可以改变这个指向的东西的内容）需在结尾添加_cPtr\n局部变量 以下划线开头，第一个单词代表变量的类型(STL中的情况使用小驼峰法命名)，第二个单词为项目名称，第三个单词为变量意义（使用小驼峰法），每个单词之间加下滑线，例如： Sprite* _sprite_xzpt_up_leaves_ptr; int _int_xzpt_Level; std::vector\u0026lt;Sprite\u0026gt; _vectorSprite_xzpt_listMoveShape; std::list\u0026lt;xzptSprite*\u0026gt; _listXzptSpritePtr_xzpt_listShape;\n全局变量 以g_开头，第一个单词代表变量的类型(STL中的情况使用小驼峰法命名)，第二个单词为项目名称，第三个单词为变量意义（使用小驼峰法），每个单词间添加下滑线，例如： char* g_char_xzpt_userInfoData_ptr; int g_int_xzpt_version;\n成员变量 以m_开头，第一个单词代表变量的类型(STL中的情况使用小驼峰法命名)，第二个单词为项目名称，第三个单词为变量意义（使用小驼峰法），每个单词间添加下滑线，例如： Sprite* m_sprite_xzpt_hand_ptr; int m_int_xzpt_actionNum;\n函数中的参数 直接写变量含义，例如： calMinDistanceLineWithShape(Vec2 pointX, Vec2 pointY, Vec2 pointM); 函数中的参数如果是传出数据使用，再开头添加out，使用小驼峰法，例如： calMaxTwoNumber(int num0, int num1, int\u0026amp; outResultNumber) 其他补充规则 for循环中括号内的局部循环标记量可直接定义为字母，使用字母顺序如下 i j m n x y z ，之后的不做顺序规定 其中基础类型名称在对象名中体现可以只写首字母，例如：int _i_xzpt_level; 单例对象用大写A开头，整体采用大驼峰法 常量命名 以c_开头，第一个单词代表变量的类型(STL中的情况使用小驼峰法命名)，第二个单词为项目名称，第三个单词为变量意义（使用小驼峰法），每个单词间添加下滑线，例如： const char* c_char_xzpt_direction_ptr;\n注意：常量与变量相同拥有全局常量，局部常量等情况，故规定如下 1. 局部常量为 _c_开头 2. 其他情况可直接与开头字母合并，如下(若为全局变量) const char* const cg_char_xzpt_hurdleInfoData_cPtr = \u0026quot;123.txt\u0026quot;; 或 const char* const gc_char_xzpt_hurdleInfoData_cPtr = \u0026quot;123.txt\u0026quot;; 此处gc与cg皆可\n静态量命名 以s_开头，第一个单词代表变量的类型(STL中的情况使用小驼峰法命名)，第二个单词为项目名称，第三个单词为变量意义（使用小驼峰法），每个单词间添加下滑线，例如： static bool s_bool_xzpt_firstTimeGetDesign; 此处注意与常量注意相同，若遇到常量，静态，全局等因素组合，除局部因素将_s加在开头外，其他因素皆可直接组合例如： static cont bool scg_bool_xzpt_firstTimeGetDesign = true; scg可任意排列组合\n函数命名 函数名必须直观，并且能正确表达其内在功能 对于函数参数中的引用和指针类型视情况以const修饰 对于不修改数据成员的类成员函数，以const修饰 函数名以小写开头，使用小驼峰法 返回值为布尔型的一些检测函数，正确的要返回true，错误的返回false，不要调转含义 宏命名规范 尽量不使用宏定义 如果使用宏需全部大写，每个单词以下滑线分割 typedef类型命名规范 typedef std::vector\u0026lt;int\u0026gt; SeqInt; //vector的全部都在前面加Seq。 typedef ::std::map\u0026lt;int, int\u0026gt; DictIntInt;//map在cdl中加前缀Dict，在代码中用Map\n必须以大写开头。 命名翻译的是内部的组成，例如SeqInt，一看就是vector。不能改为PlayerId这种具有确切意义的命名，缺乏通用性。具体含义应该在变量名上反映出来。 代码风格 空格放置 循环后加空格再加括号，例：for (int i = 0; i \u0026lt; 10; ++i) 函数名后不需要加空格，紧跟( ) ( 后紧跟与 )后紧跟不加空格 嵌套( ) 与( ) 之间加空格如：if ( (x == 1) \u0026amp;\u0026amp; (x == 2) ) ;不是结尾加空格 除[ ]、.、-\u0026gt;、::外，双目操作符， 如=、+=、\u0026gt;=、\u0026lt;= 、+、* 、% 、\u0026amp;\u0026amp; 、||、\u0026lt;\u0026lt;、^等两侧各留一个空格。 单目操作符如!、~、++、--、\u0026amp;（地址运算符）与操作数之间不留空格。 当一个函数的返回值是指针变量或引用变量时，类型与操作符（*或\u0026amp;）之间不留空格，操作符之后留一个空格； 定义指针时，*放在对象前，与对象中间无空格，当作为函数入参时，*放在类后，与类中间无空格 { } 用于初始化时不换行，在中间加空格 布局规范 每个函数，成员函数声明之间保留一个空格 同一个函数体内，有语义转换时，保留一个空行 { }会换行 ++ --前后可选择时，放在前面 { } 用于初始化时不换行，在中间加空格 注释规范 块注释使用/* */， 行注释使用// 函数声明前需注释函数含义（除非特别简单能从函数命名推测出来）（若函数功能简单，无需介绍返回值与参数也可以使用 //直接写注释）具体格式如下： 1 2 3 4 5 6 7 8 /** * @brief 这里写函数功能 * @param i 参数1 * @return 返回说明 * -\u0026lt;em\u0026gt;false\u0026lt;/em\u0026gt; fail * -\u0026lt;em\u0026gt;true\u0026lt;/em\u0026gt; succeed */ bool funciotn(int i) 代码的注释放在该行代码上 函数实现的开头需要写函数实现的大致步骤（特别简单的可不写） 每个文件最前面需写注释，格式如下(可适当删除不需要的项）)： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /** * @file Example.h * @brief 对文件的简述 * Details. * * @author wangxinxiao * @email wxx1035@163.com * @version 1.0.0.1(版本号) * @date 2022/5/11 * @license GNU General Public License (GPL) * * Remark : Description * * Change History : * \u0026lt;Date\u0026gt; | \u0026lt;Version\u0026gt; | \u0026lt;Author\u0026gt; | \u0026lt;Description\u0026gt; * 2014/01/24 | 1.0.0.1 | wangxinxiao | Create file * */ 其他规范 符合表达式需要使用小括号，不要使用默认优先级 判断指针是否为空，如：if (ptr == nullptr) 判断是否为某个值时，值放在前面，如：if (0 == i) 判断bool时，如：if (flag) 与 if (!flag) ","date":"2024-04-29T00:00:00Z","permalink":"https://xinxiao.wang/p/rulecpp/","title":"王新晓的代码规范（C++）"}]